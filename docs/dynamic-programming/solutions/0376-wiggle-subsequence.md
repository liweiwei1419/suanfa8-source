---
title: 「力扣」第 376 题：摆动序列（中等）
icon: yongyan
category: 动态规划
tags:
  - 动态规划
---

+ 题目链接：[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)。

## 题目描述

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 $O(n)$ 时间复杂度完成此题?

这个问题我们在「动态规划」章节的学习当中，把它作为了练习。

## 方法一：动态规划

「动态规划」的方法基于求解过程需要满足「无后效性」，定义状态如下：

+ `dp[i][0]` 表示：以区间 `[0..i]` 个元素中的 **某一个** 为结尾的最长的上升的「摆动序列」的长度；
+ `dp[i][1]` 表示：以区间 `[0..i]` 个元素中的 **某一个** 为结尾的最长的下降的「摆动序列」的长度。

> 友情提示：区别于「力扣」第 300 题（最长上升子序列）与「力扣」第 53 题（最大子序和），状态的定义中不要求 `nums[i]` 必需被选取。可以思考：如果要求 `nums[i]` 必需被选取，推导状态转移方程会造成什么问题？

当遍历到一个新的数时，这个数与之前被选择的「摆动子序列」的最后一个元素相比，可能的变化情况有 3 种：① 上升 ② 下降 ③ 等于。为了避免叙述冗长，「动态规划」解法的「状态转移方程」「初始化」「输出」我们写在「参考代码 1」中。

**参考代码 1**：

```Java []
public class Solution {

    public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int[][] dp = new int[len][2];
        dp[0][0] = 1;
        dp[0][1] = 1;
        for (int i = 1; i < len; i++) {
            if (nums[i - 1] < nums[i]) {
                // 情况 1：上升
                // 保持不变，相当于 nums[i] 不选
                dp[i][0] = dp[i - 1][0];
                // 接在原来下降的部分后面形成更长的子序列
                dp[i][1] = dp[i - 1][0] + 1;
            } else if (nums[i - 1] > nums[i]) {
                // 情况 2：下降
                // 接在原来上升的部分后面形成更长的子序列
                dp[i][0] = dp[i - 1][1] + 1;
                // 保持不变，相当于 nums[i] 不选
                dp[i][1] = dp[i - 1][1];
            } else {
                // 情况 3：nums[i - 1] == nums[i]，可以认为 nums[i] 没有出现过一样
                dp[i][0] = dp[i - 1][0];
                dp[i][1] = dp[i - 1][1];
            }
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，其中 $N$ 是输入数组的长度；
+ 空间复杂度：$O(N)$，为了记录所有的状态，我们使用的状态数组的大小为 $2N$。

事实上，我们将示例 2 在草稿纸上画出示意图。

![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7qpjxhwj21hc0u0taq.jpg){:align=center}

发现：**只需要关注上面「折线图」中上升和下降的转折点**，把它们单独拿出来，就构成了原始输入数组的一个长度最长的「摆动序列」。

## 方法二：贪心算法

**「贪心算法」的直觉**：

只关注「拐点」。这是因为我假设当前遍历到的元素在一个上升的区间当中，如果这个值越大，那么它的下一个元素数值的变化减少的概率你越大，如果「下一个元素数值的变化减少」真的发生了，摆动序列的长度就增加了 $1$。

![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h2u7qsji32j21hc0u0jtg.jpg){:align=center}


在编写代码的过程中，需要注意「等于」的情况，我们将其它的细节放在「参考代码 2」中。

**参考代码 2**：

```Java []
public class Solution {

    public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int prev = 0;
        int curr;

        int res = 1;
        for (int i = 1; i < len; i++) {
            curr = nums[i] - nums[i - 1];
            if ((curr > 0 && prev <= 0) || (curr < 0 && prev >= 0)) {
                res++;
                prev = curr;
            }
        }
        return res;
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(n)$，其中 $n$ 是序列的长度，我们只需要遍历该序列一次；
+ 空间复杂度：$O(1)$。我们只需要常数空间来存放若干变量。

