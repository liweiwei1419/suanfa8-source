---
title: （公众号文章）树形 DP  是个什么玩意儿
icon: yongyan
category: 动态规划
tags:
  - 动态规划
---


**例：「力扣」第 124 题：二叉树中的最大路径和（困难）**

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**


![](https://tva1.sinaimg.cn/large/008i3skNgy1gxbldhfgecj30fc0ak3yl.jpg)


```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**


![](https://tva1.sinaimg.cn/large/008i3skNgy1gxbldk4gyuj30jc0f2gm0.jpg)


```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 10^4]`
- `-1000 <= Node.val <= 1000`

**思路分析**：

首先「后序遍历」是肯定要的，因此我们写出的代码一定会有递归，并且在递归函数里：

+ 首先写递归终止条件：
+ 然后，先计算两个子树的结果，然后得到了两个子树的结果以后才与计算当前结点有关的变量的值。

题目只问最大路径的和是多少，并没有要我们得到这个最大路径。这样的问题很可能需要使用「动态规划」的思想去解决。

而树形动态规划的状态定义没有其它动态规划那么明显，它不是画表格，它有可能：

+ 设计在递归函数中；
+ 在递归函数的返回值里设计多个变量返回。

> 使用「动态规划」解决的问题通常都有这样的特点：「动态规划」只记录了一系列选择的结果，并不记录过程，因此「动态规划」对数据是有「压缩」的。因此我们会看到很多「动态规划」的问题只要求我们得到一个结果。并且如果做过「背包问题」的朋友就会知道，从「动态规划」的表格中，只能通过「倒序」的方式恢复满足条件的一个解，不能得到所有解。

其实我们需要明确题目给出的「路径」的概念。根据示例，「路径」的形态，不只是「从上到下」或者「从下到上」，有可能有「折线」的形态。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gxbldpxcwzj30oi0iowf7.jpg)

题目当中说：「同一个节点在一条路径序列中 **至多出现一次** 」「该路径 **至少包含一个** 节点」「且不一定经过根节点」，这些都是非常关键的信息。

因为「该路径 **至少包含一个** 节点」，因此我们在 **设计状态** 的时候就可以考虑让当前考虑的结点必须被选择。

在当前结点必须被选择的时候，路径可能来自左子树，也可能来自右子树，这两件事情需要分类讨论，我们对状态的定义只要求只能来自左子树和右子树中的一条路径。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gxbldu4pflj316a0js0uj.jpg)

>「必须经过子问题的根结点」和「只保留左子树和右子树其中一条路径」这两件事情就是「动态规划」的「无后效性」的应用。

我们把不确定的、需要分类讨论的事情确定下来，以便求解。

我们直接给出「参考代码」，我们把需要注意的地方作为注释写在代码中，「树形 DP」与的状态设计与状态转移是隐含在递归方法里的，这一点很不一样。


**参考代码**：

```java
public class Solution {

    private int res;

    public int maxPathSum(TreeNode root) {
        res = Integer.MIN_VALUE;
        dfs(root);
        return res;
    }


    /**
     * 规定 node 必须被选取
     *
     * @param node
     * @return 返回必须经过 node 的不是「弯曲」的路径，即：这条路径在左子树和右子树的路径中只能选择一条
     */
    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 这里体现了「后序遍历」，先递归求解左、右子树
        // 由于结点的值有可能为负数，因此如果子树得到的路径是负数，可以舍弃，表现为和 0 取最大值
        int leftSubTreeSum = Math.max(0, dfs(node.left));
        int rightSubTreeSum = Math.max(0, dfs(node.right));
        
        // node.val 必须被选择体现在这里
        // 在深度优先遍历的过程中选出最大值
        res = Math.max(res, node.val + leftSubTreeSum + rightSubTreeSum);
        
        // node.val 必须被选择体现在这里
        return node.val + Math.max(leftSubTreeSum, rightSubTreeSum);
    }
}
```


**时间复杂度**：遍历了树一次，因此时间复杂度为 $O(N)$，这里 $N$ 为二叉树的结点总数。


**总结**：

初学树形 DP 可能会觉得比较难理解，大家不用很担心，我刚开始学习「力扣」第 337 题：打家劫舍 III 的时候，花了很长的时间，和一个扣友讨论过很多次，才理解动态规划是怎么计算的。

理解一个算法设计思想最好的办法还是多做题，我们下面给出的问题都采用了今天介绍的「后序遍历」和「动态规划」的思想解决。


**相关问题**：

+ 「力扣」第 337 题：打家劫舍 III（中等）；
+ 「力扣」第 543 题：二叉树的直径（简单）；
+ 「力扣」第 687 题：最长同值路径（中等）；
+ 「力扣」第 968 题：监控二叉树（困难）；
+ 「力扣」第 1372 题：二叉树中的最长交错路径（中等）。


今天的问题如果是第 1 次看会很晕，如果大家觉得我哪里没有讲清楚的话，可以给我留言，我们后面还可以安排讲这里的「相关问题」，把「后序遍历」和「无后效性」多讲几次，可能就会清楚很多了。

感谢大家的收看，今天周五了，又是 521，祝大家天天开心！







