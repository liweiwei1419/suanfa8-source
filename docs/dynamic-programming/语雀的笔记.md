---
title: 动态规划（语雀的笔记）
icon: yongyan
category: 动态规划
tags:
  - 动态规划
---



## 什么是「规划」

在《算法导论》这本书里，对「规划」的解释是「表格」，这个描述是非常准确的。

## 使用「动态规划」解决的问题具有以下三个特点

### 1、重复子问题

从「斐波拉契数列」求解的问题中，我们知道，如果递归地去这个问题，会遇到很多以前求解过的问题，即「重复子问题」。这些子问题不应该也不需要被重复计算。

### 2、最优子结构

求解子问题得到的最优解，组成了规模更大的原问题的最优解，这样的问题，我们称之为具有「最优子结构」。

动态规划问题通常应用的场景是：我们直接求解这个问题感觉难度较大，但是我们把这个问题拆分为规模更小的问题的时候，这个问题的解通常也就能够找到，这样的解决问题的实现通常都要「借助」递归来实现。

### 3、无后效性

+ 每个子问题只求解一次；

- 在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；
- 某阶段状态一旦确定，就不受之后阶段的决策影响。

我们将通过具体的例子来解释可以使用「动态规划」方法解决的问题的这 3 个特点。我们先来看一个最最简单的问题：「斐波拉契数列」。

## 例题：「力扣」第 509 题：[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)。

### 方法一：使用递归

分析：虽然可以通过，但是进行了大量的重复计算。因此时间复杂度是认为指数级别。（这个结论比较粗糙，由于我们是算法基础课程，就不带着代价去研究这个细节了。）

**参考代码**：

```java
class Solution {
    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        return fib(N - 1) + fib(N - 2);
    }
}
```

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gxbet1rc97j315o0phabw.jpg)

解决的办法是使用一个数组作为「缓存」，在遇到同样的问题的时候，先查表。

- 如果已经计算过，就不再计算；
- 如果还没有计算过，就递归去计算一次。

**参考代码**：

```java
import java.util.Arrays;

public class Solution {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }

        // 0 要占一个位置，所以设置 N + 1 个位置
        int[] memo = new int[N + 1];
        Arrays.fill(memo, -1);
        return fib(N, memo);
    }

    public int fib(int n, int[] memo) {
        if (n == 0) {
            return 0;
        }

        if (n == 1) {
            return 1;
        }

        if (memo[n] == -1) {
            memo[n] = fib(n - 1) + fib(n - 2);
        }
        return memo[n];
    }
}
```

### 方法二：动态规划

上面「递归」求解的过程是「自底向上」的过程，而「动态规划」告诉我们一种求解问题的思路：「自底向上」，事实上，我们人在计算的时候，更多会这样去计算。

- 「自上而下」和 「自底向上」的解法通常都可以称为「动态规划」；
- 如果没有学习过「动态规划」，通过「递归」求解，应该需要知道做了大量重复计算，因此需要加入缓存，这种做法叫「记忆化递归」或者「记忆化搜索」；

- 而使用「自底向上」的思路可以解决在入门阶段的绝大多数「动态规划」问题，我们就是去想一下，这个问题最开始的时候是什么样子，而不是直接去解决这个问题，请大家在练习的过程中逐渐体会这个思路。

**注意**：并不是所有的「动态规划」问题都可以「自底向上」去做，但是初学的时候，大家可以直接适应这种解法，因为「自上而下」的写法就是「递归」的写法，我们已经相对熟悉。

**参考代码**：

```java
public class Solution {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        int[] dp = new int[N + 1];

        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < N + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
}
```

这一小节，希望大家能够体会「动态规划」的一个思路，「自底向上」，并且理解使用「动态规划」解决问题的一个特征：「重复子问题」。

因为有「重复子问题」，我们在「自底向上」求解的过程中，通过先解决更小规模的问题，在处理更大规模的问题的时候，直接使用了更小规模问题的结果，进而原问题得到了解决。

## 练习

1、「力扣」第 70 题：[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)。



# 最优子结构







这一节我们向大家介绍「最优子结构」这个概念，具体来说就是：问题的最优解参考了子问题的最优解。



这个提法比较学术，我们还是用具体的例子和大家解释。这道题是



## 例 1：[「力扣」第 322 题：零钱兑换](https://leetcode-cn.com/problems/coin-change/)中等

思路：



- 看题目的问法，只问最优值是多少，没有要我们求最优解，一般情况下就是「动态规划」可以解决的问题。
- 最优子结构其实比较明显，我们看示例 1：



```plain
输入: coins = [1, 2, 5], amount = 11
```



凑成面值为 `11` 的最小硬币数可以由以下 3 者的最小值得到：



- 凑成面值为 `10` 的最小硬币数（假设已知） + 面值为 `1` 的这一枚硬币；
- 凑成面值为 `9` 的最小硬币数（假设已知） + 面值为 `2` 的这一枚硬币；

- 凑成面值为 `6` 的最小硬币数（假设已知） + 面值为 `5` 的这一枚硬币；



即 `dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1)`。这就是这个问题的最优子结构，在三种选择中，选出一个最优解。



这里需要引入一个概念：状态。状态其实我们在「回溯算法」里介绍说。状态在动态规划里其实含义是一样的，依然是表示我们求解一个问题进行到哪个阶段，只不过表现这个变量不想「回溯算法」那么具体，很多时候，它是一个「概括值」。



我们这里直接把题目的问法设计成「状态」，有些问题不是这样的，我们后面再说。



#### 第 1 步：定义「状态」



`dp[i]`：凑齐总价值 `i` 需要的最少硬币数，状态就是问的问题。



#### 第 2 步：写出「状态转移方程」



所谓「状态转移方程」，其实就是「最优子结构」。



根据对具体例子的分析：



```plain
 dp[amount] = min(1 + dp[amount - coin[i]]) for i in [0, len - 1] if coin[i] <= amount
```



注意的是：



- 首先硬币的面值首先要**小于等于**当前要凑出来的面值；
- 剩余的那个面值应该要能够凑出来，例如：求 `dp[11]` 需要参考 `dp[10]` ，如果不能凑出来的话，`dp[10]` 应该等于一个不可能的值，可以设计为 `11 + 1`，也可以设计为 `-1` ，它们的区别只是在具体的代码编写细节上不一样而已。



再强调一次：新状态的值要参考的值以前计算出来的「有效」状态值。这一点在编码的时候需要特别注意。

因此，不妨先假设凑不出来，因为比的是小，所以初始化的时候应该设置为一个不可能的数。



**Java 代码：**

```java
import java.util.Arrays;

public class Solution {

    public int coinChange(int[] coins, int amount) {
        // 给 0 占位
        int[] dp = new int[amount + 1];

        // 注意：因为要比较的是最小值，这个不可能的值就得赋值成为一个最大值
        Arrays.fill(dp, amount + 1);

        dp[0] = 0;

        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i - coin] != amount + 1) {
                    dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
                }
            }
        }

        if (dp[amount] == amount + 1) {
            dp[amount] = -1;
        }
        return dp[amount];
    }
}
```

注意：

- 要求的是恰好填满，所以初始化的时候需要赋值为一个不可能的值：`amount + 1`。只有在有「正常值」的时候，「状态转移」才可以正常发生。

## 总结



可能有的朋友要问了，斐波拉契数列貌似没有「最优子结构」，事实上的确是这样，严格来说「斐波拉契数列」不是「动态规划」问题，但它却是理解「动态规划」问题的一个例子，主要是通过这个例子理解「动态规划」「自底向上」求解的思想和「重复子问题」的特征。大家先不要去纠结这件事情。



这节我们向大家介绍了「最优子结构」。希望大家能够体会，我们在设计「状态」的时候，仅仅只是用一个数值表示了求解一个问题的阶段，所以这个数值是一个「概括性」的数值，它不是具体解，但是它可以代表具体解。



这里要注意：对「状态」的定义一定要非常准确，在这里我的建议是，如果状态定义不是题目问的那个样子，把我们对状态的定义都作为注释写在代码里。



只有「状态」定义准确，「状态转移方程」才会「准确」。



其实求解这个问题，还利用到了一个「动态规划」问题的一个特点「无后效性」。我们在下一节向大家解释。

## 练习

### 练习 1：[「力扣」第 279 题：完全平方数](https://leetcode-cn.com/problems/perfect-squares/)中等

Java 代码：

```java
import java.util.Arrays;

class Solution {

    // 说明 dp[0] = 0; 的合理性
    // 表达式 1 + dp[i - j * j] = 1 ，表示它自己就是一个完全平方式，所以结果是 1

    public int numSquares(int n) {
        // 0 要占用一个位置
        int[] dp = new int[n + 1];

        // 赋初值，设置成为 4 是数学定理保证
        Arrays.fill(dp, 4);
        // 该值被参考，设置成 0
        dp[0] = 0;

        // 一个一个求，自底向上
        for (int i = 1; i <= n; i++) {
            for (int k = 0; k * k <= i; k++) {
                dp[i] = Math.min(dp[i], dp[i - k * k] + 1);
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 7168;
        Solution solution = new Solution();
        int numSquares = solution.numSquares(n);
        System.out.println(numSquares);
    }
}
```

### 练习 2：[「力扣」第 343 题：整数拆分](https://leetcode-cn.com/problems/integer-break/)中等

- 题解：[“贪心选择”性质的简单证明、记忆化搜索、动态规划 （Python、Java）](
  - https://leetcode-cn.com/problems/integer-break/solution/tan-xin-xuan-ze-xing-zhi-de-jian-dan-zheng-ming-py/)



# 无后效性

我们在第 1 节向大家介绍过「无后效性」的两层含义：


- 在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
- 某阶段状态一旦确定，就不受之后阶段的决策影响。



下面我们就通过具体的例子向大家进行说明。


## 例 1：[「力扣」第 198 题：打家劫舍](https://leetcode-cn.com/problems/house-robber/)中等


这道问题是经典的「力扣」第 198 题：打家劫舍。题目只问最优值，并没有问最优解，因此绝大多数情况下可以考虑使用「动态规划」的方法。


如果我们直接将问题的问法定义成状态，会发现，当前这个房子「偷」和「不偷」会影响到后面的房子「偷」与「不偷」。


一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响，还是上一节和大家介绍的方法：把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。


#### 第 1 步：设计状态


「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。


由于当前这一个房屋是否有两种选择：（1）偷；（2）不偷。


`dp[i][0]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间偷，能够偷窃到的最高金额；
`dp[i][1]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间不偷，能够偷窃到的最高金额。


说明：这个定义是**有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值**，第 2 维保存了当前最优值的决策，这种**通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的**。


强调：


> 无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。



再联系状态的定义：状态是一个概括的值，这个值是怎么来的，并不记录。因为状态定义更细致，后面的决策才不会影响到前面的决策。


#### 第 2 步：状态转移方程


「状态转移方程」可以理解为「不同阶段之间的联系」。


今天只和昨天的状态相关，依然是分类讨论：


- 下标为 `i` 的房屋不偷：或者是上一间不偷，或者是上一间偷，取二者最大值，即：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])`；
- 下标为 `i` 的房屋偷：只需要从上一间不偷，这一间偷，即：`dp[i][1] = dp[i - 1][0] + nums[i]`。



#### 第 3 步：考虑初始化


从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了。好在不难判断：`dp[0][0] = 0` 与 `dp[0][1] = nums[0]`；


这里有一种**技巧，可以把状态数组多设置一行**，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。


#### 第 4 步：考虑输出


由于状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况。下标为 `len - 1` 这个房屋可以偷，也可以不偷，取二者最大值。


**参考代码 1**：


Java 代码：


```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return nums[0];
        }

        // dp[i][0]：考虑区间 [0, i] ，并且下标为 i 的这个房屋不偷
        // dp[i][1]：考虑区间 [0, i] ，并且下标为 i 的这个房屋偷
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        // int[] nums = {1, 2, 3, 1};
        // int[] nums = {2, 7, 9, 3, 1};
        int[] nums = {2, 1, 4, 5, 3, 1, 1, 3};
        int res = solution.rob(nums);
        System.out.println(res);
    }
}
```


**复杂度分析**：


- 时间复杂度：$O(N)$，$N$ 是数组的长度；
- 空间复杂度：$O(N)$，状态数组的大小为 $2N$。



**参考代码 2**：根据方法一：状态数组多设置一行，以避免对极端用例进行讨论。


Java 代码：


```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[len + 1][2];

        // 注意：外层循环从 1 到 =len，相对 dp 数组而言，引用到 nums 数组的时候就要 -1
        for (int i = 1; i <= len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i - 1];
        }
        return Math.max(dp[len][0], dp[len][1]);
    }
}
```


**复杂度分析**：


- 时间复杂度：$O(N)$，$N$ 是数组的长度；
- 空间复杂度：$O(N)$，状态数组的大小为 $2(N + 1)$，记为 $O(N)$。



#### 第 5 步：考虑是否复用表格


由于我们只关心最后一个状态值。并且


`dp[i]` 只参考了 `dp[i - 1]` 的值，状态可以压缩，可以使用「滚动数组」完成。


值得说明的是：状态压缩的代码丢失了一定可读性，也会给编码增加一点点难度。


**参考代码 3**：使用「滚动数组」技巧，将空间优化到常数级别


在编码的时候，需要注意，只要访问到 `dp` 数组的时候，需要对下标 `% 2`，等价的写法是 `& 1`。


Java 代码：

```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return nums[0];
        }

        int[][] dp = new int[2][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < len; i++) {
            dp[i & 1][0] = Math.max(dp[(i - 1) & 1][0], dp[(i - 1) & 1][1]);
            dp[i & 1][1] = dp[(i - 1) & 1][0] + nums[i];
        }
        return Math.max(dp[(len - 1) & 1][0], dp[(len - 1) & 1][1]);
    }
}
```


**复杂度分析**：


- 时间复杂度：$O(N)$，$N$ 是数组的长度；
- 空间复杂度：$O(1)$，状态数组的大小为 $4$，常数空间。



## 总结


「状态」和「状态转移方程」得到以后，这个问题其实就得到了解决，剩下的一些细节的问题在编码的时候只要稍微留意一点就行了。


到这里「重复子问题」、「最优子结构」、「无后效性」我们就都向大家介绍完了。「动态规划」告诉我们可以「自底向上」去考虑一件事情，并且记录下求解问题的中间过程。


「动态规划」问题没有套路，我们只有通过不断地联系，去掌握状态设计的一般方法和技巧，体会上面所说的「动态规划」的基本概念和基本特征。


## 练习

### 练习 1：[「力扣」第 62 题：不同路径](https://leetcode-cn.com/problems/unique-paths/)中等

#### 方法一：动态规划

其实就是填写二维表格。

- 状态：`dp[i][j]` 表示走到坐标 `(i, j)` 的路径总数；
- 状态转移方程：思路依然是分类讨论，走到坐标 `(i, j)`  可以从上方下来，也可以从左边过来，路径总数是二者之和；



```java
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```


当前 `dp[i][j]` 值的来源：上面和前面的值之和。


- 初始化：数组 `dp` 的第 1 行和第 1 列都得显示赋值为 1；
- 输出：`dp[m - 1][n - 1]`。
- 表格复用：可以滚动数组，也可以只压缩到一维。



Java 代码：

```java
public class Solution {

    // 语义清晰，但是空间可以只用一行

    public int uniquePaths(int m, int n) {
        if (m < 0 || n < 0) {
            return 0;
        }
        int[][] dp = new int[m][n];
        // 第 1 行（行索引为 0）只能沿着边缘走
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        // 第 1 列（列索引为 0）只能沿着边缘走
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }

    public static void main(String[] args) {
        // 输入: m = 7, n = 3
        // 输出: 28
        Solution solution = new Solution();
        int m = 7;
        int n = 3;
        int uniquePaths = solution.uniquePaths(m, n);
        System.out.println(uniquePaths);
    }
}
```

动态规划得到的 `dp` 数组：`[[1, 1, 1, 1], [1, 2, 3, 4], [1, 3, 6, 10], [1, 4, 10, 20], [1, 5, 15, 35]]`。
Python 代码：

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1

        for i in range(m):
            for j in range(n):
                if i == 0:
                    if j == 0:
                        continue
                    dp[0][j] = dp[0][j - 1]
                elif j == 0:

                    dp[i][0] = dp[i - 1][0]
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[- 1][- 1]


if __name__ == '__main__':
    s = Solution()
    res = s.uniquePaths(7, 3)
    print(res)
```

- 增加「哨兵」的写法，少写一些特殊判断，这个技巧比较常见。

如何想到的：把状态表格抄一遍，或者自己把矩阵画出来，就能知道这个数组怎么来的。每一行，只依赖上一行的结果，我们完全可以用一行来逐步更新。第 1 个元素肯定是 `1`，并且第 1 行元素肯定全是 `1`。
初始化的时候比较麻烦，因此可以考虑「哨兵」写法，将数组 `dp` 多写一行，多写一列。
Java 代码：

```java
public class Solution {

    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        // 初始化的时候 dp[0][1] = 1; 或者 dp[1][0] = 1; 均可
        dp[1][0] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];
            }
        }
        return dp[m][n];
    }

    public static void main(String[] args) {
        // 输入: m = 7, n = 3
        // 输出: 28
        Solution2 solution = new Solution2();
        int m = 7;
        int n = 3;
        int uniquePaths = solution.uniquePaths(m, n);
        System.out.println(uniquePaths);
    }
}
```

Python 代码：

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        dp[1][0] = 1
        for i in range(m):
            for j in range(n):
                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j]
        return dp[m][n]


if __name__ == '__main__':
    s = Solution()
    res = s.uniquePaths(7, 3)
    print(res)
```

- 一维动态规划表格

注意到其实在左边第一行和上边第一行，肯定都为 $1$，还有就是新一行的值只与上一行有关，所以我们完全可以只设置一维数组，将这道题完成。其实使用 $2$ 个变量也可以完成，但是这样的代码可读性比较差，在这里就不写了。
Java 代码：

```java
public class Solution {

    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        dp[0] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }

    public static void main(String[] args) {
        // 输入: m = 7, n = 3
        // 输出: 28
        Solution3 solution = new Solution3();
        int m = 7;
        int n = 3;
        int uniquePaths = solution.uniquePaths(m, n);
        System.out.println(uniquePaths);
    }
}
```

Python 代码：

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1] * n
        for i in range(1, m):
            # 从下标 2 开始走就行了
            for j in range(1, n):
                dp[j] = dp[j] + dp[j - 1]
        return dp[-1]


if __name__ == '__main__':
    m = 3
    n = 4
    solution = Solution()
    result = solution.uniquePaths(m, n)
    print(result)
```

#### 方法二：数学方法（用组合数公式）

用组合数来求解，走到坐标为 `(m, n)` 的地方，向下走 `m - 1` 格，向右边走 `n - 1` 格。一共走 `m + n - 2` 格。
即：机器人一定会走 $$m+n-2$$ 步，即从 $$m+n-2$$ 中挑出 $$m-1$$ 步向下走即可，即 $$C_{m+n-2}^{m-1}$$ 为所求。
Python 代码：

```python
class Solution:
    

    def __factorial(self, n):
        res = 1
        while n > 1:
            res *= n
            n -= 1
        return res

    def __combination(self, m, n):
        """
        从 n 个物品里选出 m 个物品的组合数
        :param m:
        :param n:
        :return:
        """
        return self.__factorial(n) // (self.__factorial(m) * self.__factorial(n - m))

   def uniquePaths(self, m: int, n: int) -> int:
        return self.__combination(m - 1, m + n - 2)


if __name__ == '__main__':
    m = 7
    n = 3
    solution = Solution()
    result = solution.uniquePaths(m, n)
    print(result)
```

#### 方法三：记忆化递归

Python 代码：

```python
class Solution:

    def __init__(self):
        self.cached = None

    def __path(self, i, j):
        if self.cached[i][j] != 0:
            return self.cached[i][j]

        if i == 0 and j == 0:
            return 1
        path_ways = 0
        if i == 0:
            path_ways = self.__path(0, j - 1)
        elif j == 0:
            path_ways = self.__path(i - 1, 0)
        else:
            path_ways = self.__path(i, j - 1) + self.__path(i - 1, j)
        self.cached[i][j] = path_ways
        return path_ways

    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        self.cached = [[0 for _ in range(n)] for _ in range(m)]

        return self.__path(m - 1, n - 1)
```

用测试用例得到的缓存数组：`[[0, 1, 1, 1], [1, 2, 3, 4], [1, 3, 6, 10], [1, 4, 10, 20], [1, 5, 15, 35]]`。

### 练习 2：[「力扣」第 63 题：不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)中等

#### 方法一：动态规划


Python 代码：

```python
from typing import List


class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        if m == 0:
            return 0
        n = len(obstacleGrid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]

        if obstacleGrid[0][0] == 1:
            return 0
        else:
            dp[0][0] = 1

        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                    continue
                if i == 0:
                    if j == 0:
                        continue
                    dp[0][j] = dp[0][j - 1]
                elif j == 0:
                    dp[i][0] = dp[i - 1][0]
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]


if __name__ == '__main__':
    obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
    s = Solution()
    res = s.uniquePathsWithObstacles(obstacleGrid)
    print(res)
```


- 表格复用技巧：使用一维数组记录状态值。
- 一维数组 + 哨兵



Java 代码：

```java
public class Solution {

    // 空间复杂度：O(N)，N 是矩阵的列数

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        if (m == 0) {
            return 0;
        }
        int n = obstacleGrid[0].length;
        int[] dp = new int[n + 1];

        // 技巧：回避了对边界条件的判断
        dp[1] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j + 1] = 0;
                } else {
                    dp[j + 1] += dp[j];
                }
            }
        }
        return dp[n];
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:

        m = len(obstacleGrid)
        if m == 0:
            return 0
        n = len(obstacleGrid[0])

        if obstacleGrid[0][0] == 1:
            return 0

        dp = [0] * n
        # 这一步不要忘记了
        dp[0] = 1
        # 再写后面几行
        for row in range(m):
            for col in range(n):
                # 【就分下面这两种情况就可以了】
                if obstacleGrid[row][col] == 1:
                    dp[col] = 0
                elif col > 0:
                    dp[col] += dp[col - 1]
                else:
                    # 第 0 列不是 0 就是 1
                    # 0 的情况首先判断了
                    # 什么都不做
                    pass
        return dp[-1]
```

C++ 代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;


class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
        int m = obstacleGrid.size();
        if (m == 0) {
            return 0;
        }
        int n = obstacleGrid[0].size();
        vector<long> dp(n + 1, 0);

        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        // 注意：这里是索引为 1 的位置
        dp[1] = 1;
        // 下面这两行赋值比较关键
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j + 1] = 0;
                } else {
                    dp[j + 1] += dp[j];
                }
            }
        }
        return dp[n];
    }
};
```

#### 方法二：记忆化递归

Python 代码：

```python
class Solution:

    def __init__(self):
        self.cached = []
        self.obstacleGrid = None

    def _path_ways(self, i, j):
        if self.cached[i][j] != 0:
            return self.cached[i][j]
        if self.obstacleGrid[i][j] == 1:
            return 0
        if i == 0 and j == 0:
            return 1
        if i == 0:
            ways = self._path_ways(0, j - 1)
        elif j == 0:
            ways = self._path_ways(i - 1, 0)
        else:
            ways = self._path_ways(i, j - 1) + self._path_ways(i - 1, j)
        self.cached[i][j] = ways
        return ways

    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        m = len(obstacleGrid)
        if m == 0:
            return 0
        n = len(obstacleGrid[0])
        self.cached = [[0 for _ in range(n)] for _ in range(m)]
        self.obstacleGrid = obstacleGrid
        return self._path_ways(m - 1, n - 1)
```

### 练习 3：[「力扣」第 64 题：最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)中等

#### 方法：动态规划

每一步只能左移或者下移。题目中给出了 `grid` 非负整数，可以保证走得越长，sum 的值越大；只能向右走或者向下走，保证了在非负整数矩阵的情况下，sum 的最小值存在。在分析清楚以后，我们可以直接在 grid 矩阵上原地修改，直接给出动态规划的解法，十分简单，逻辑也很清晰，核心代码不超过 10 行。
状态很好定义，题目中问什么，状态就定义成什么：`dp[i][j]`。
Java 代码：

```java
public class Solution {
  
		// 直接在 grid 数组上操作

    public int minPathSum(int[][] grid) {
        if (grid == null) {
            return 0;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 1; i < n; i++) {
            grid[0][i] = grid[0][i] + grid[0][i - 1];
        }
        for (int i = 1; i < m; i++) {
            grid[i][0] = grid[i][0] + grid[i - 1][0];
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
            }
        }
        return grid[m - 1][n - 1];
    }

    public static void main(String[] args) {
        int[][] grid = {{1, 2, 5}, {3, 2, 1}};
        Solution solution = new Solution();
        int minPathSum = solution.minPathSum(grid);
        System.out.println(minPathSum);
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:

        m = len(grid)
        if m == 0:
            return 0
        n = len(grid[0])

        for col in range(1, n):
            # 第 0 行特殊处理，不要忘记了
            grid[0][col] += grid[0][col - 1]
        for row in range(1, m):
            grid[row][0] += grid[row - 1][0]
            for col in range(1, n):
                grid[row][col] += min(grid[row - 1][col], grid[row][col - 1])
        return grid[-1][-1]


if __name__ == '__main__':
    grid = [[1, 3, 1],
            [1, 5, 1],
            [4, 2, 1]]

    s = Solution()
    res = s.minPathSum(grid)
    print(res)
```

- 技巧：表格复用

Java 代码：

```java
public class Solution {

    public int minPathSum(int[][] grid) {
        if (grid == null) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;

        int[] dp = new int[n];
        dp[0] = grid[0][0];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) {
                    dp[j] = grid[0][j] + dp[j - 1];
                } else if (j == 0 && i > 0) {
                    dp[j] = dp[j] + grid[i][0];
                } else if (i != 0) {
                    dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
                }
            }
        }
        return dp[n - 1];
    }
}
```

**复杂度分析**：

- 时间复杂度：$$O(MN)$$，这里 $$M$$ 和 $$N$$ 分别是矩阵的长和宽；
- 空间复杂度：$$O(N)$$。

### 练习 4：[「力扣」第 120 题：不同路径 II](https://leetcode-cn.com/problems/triangle/)中等

思路：关键的地方在于三角形「从上到下」和「从下到上」思考的方向的不同。
1、从上到下：最边上的点只能从最边上的点走过来；
2、从下到上：每一点都有两个孩子：左孩子和右孩子，可以少掉很多讨论。
Java 代码：

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    public int minimumTotal(List<List<Integer>> triangle) {
        int len = triangle.size();
        if (len == 0) {
            return 0;
        }
        // 注意：这里 len + 1 是为了防止越界
        int[] dp = new int[len + 1];
        for (int i = len - 1; i >= 0; i--) {
            for (int j = 0; j < i + 1; j++) {
                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
            }
            // 每一步观察是不是我们想要的，这是调试的重要方法
            // System.out.println(Arrays.toString(dp));
        }
        return dp[0];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        List<Integer> step1 = generateIntegerList(new int[]{2});
        List<Integer> step2 = generateIntegerList(new int[]{3, 4});
        List<Integer> step3 = generateIntegerList(new int[]{6, 5, 7});
        List<Integer> step4 = generateIntegerList(new int[]{4, 1, 8, 3});


        List<List<Integer>> triangle = new ArrayList<>();
        triangle.add(step1);
        triangle.add(step2);
        triangle.add(step3);
        triangle.add(step4);
        int minimumTotal = solution.minimumTotal(triangle);
        System.out.println(minimumTotal);
    }

    private static List<Integer> generateIntegerList(int[] nums) {
        List<Integer> arr = new ArrayList<>();
        for (int num : nums) {
            arr.add(num);
        }
        return arr;
    }
}
```

Python 代码：

```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        size = len(triangle)
        if size == 0:
            return 0
        dp = [0] * size
        for i in range(size):
            dp[i] = triangle[size - 1][i]
        for i in range(size - 2, - 1, -1):
            for j in range(i + 1):
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
        return dp[0]
```

Python 代码：（原地修改）

```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        size = len(triangle)
        if size == 0:
            return 0
        dp = triangle[-1]
        for i in range(size - 2, -1, -1):
            for j in range(len(triangle[i])):
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
        return dp[0]
```

### 练习 5：[「力扣」第 91 题：解码方法](https://leetcode-cn.com/problems/decode-ways/)中等

Java 代码：

```java
public class Solution {

    public int numDecodings(String s) {
        int len = s.length();
        if (len == 0) {
            return 0;
        }

        int[] dp = new int[len];
        char[] charArray = s.toCharArray();
        if (charArray[0] == '0'){
            dp[0] = 0;
        } else {
            dp[0] = 1;
        }

        // dp[i]：前缀字符串 s[0:i] 的解码方法数
        for (int i = 1; i < len; i++) {
            int currentValue = 0;
            char cur = charArray[i];
            if (cur != '0') {
                currentValue += dp[i - 1];
            }

            int pre = Integer.parseInt(s.substring(i - 1, i + 1));
            if (pre <= 26 && pre >= 10) {
                if (i - 2 < 0) {
                    currentValue++;
                } else {
                    currentValue += dp[i - 2];
                }
            }
            dp[i] = currentValue;
        }
        return dp[len - 1];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "12";
        int res = solution.numDecodings(s);
        System.out.println(res);
    }
}
```

（本节完）



**第 16.4 节 动态规划典型问题**

## 练习 1：[「力扣」第 300 题：最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)

- 题解：[动态规划 、优化（以贪心和二分作为子过程）](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/)

扩展问题：[「力扣」第 354 题：俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

- 题解：[贪心算法、二分查找（Python 代码、Java 代码）](https://leetcode-cn.com/problems/russian-doll-envelopes/solution/tan-xin-suan-fa-er-fen-cha-zhao-python-dai-ma-java/)

### 练习 2：[「力扣」第 1143 题：最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- 题解：[动态规划](https://liweiwei1419.gitee.io/leetcode-algo/2018/05/14/leetcode-algo/1143-longest-common-subsequence/)

### 练习 3：[「力扣」第 53 题：最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

- 题解：[动态规划、分治法](https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)

### 练习 4：[「力扣」第 376 题：摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

- 题解：[「力扣」第 376 题：摆动序列（动态规划）](https://blog.csdn.net/lw_power/article/details/103970211)

### 练习 5：[「力扣」第 72 题：编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- 题解：[动态规划（Java）](https://leetcode-cn.com/problems/edit-distance/solution/dong-tai-gui-hua-java-by-liweiwei1419/)

### 练习 6：[「力扣」第 120 题：三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

- 题解：

### 练习 7：[「力扣」第 152 题：乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

- 题解：[二维动态规划](https://leetcode-cn.com/problems/maximum-product-subarray/solution/er-wei-dong-tai-gui-hua-by-liweiwei1419/)

### 练习 8：[「力扣」第 887 题：鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

- 题解：[动态规划（只解释官方题解方法一）（Java）](https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/)



## 



第 16.5 节 0-1 背包问题

### 第 1 版：使用二维数组，不设置「哨兵」行



Java 代码：



```java
import java.util.Scanner;

public class Main {

    // 0-1 背包问题
    // 判题地址：https://www.acwing.com/problem/content/description/2/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        // 因为包含 0，所以 + 1
        int[][] dp = new int[N][V + 1];


        // 先写第 1 行
        for (int j = 1; j <= V; j++) {
            // 第 1 个物品的体积要小于等于背包容量
            if (weight[0] <= j) {
                dp[0][j] = value[0];
            }
        }

        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= V; j++) {
                dp[i][j] = dp[i - 1][j];
                if (weight[i] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }

        // 输出
        System.out.println(dp[N - 1][V]);
    }
}
```



### 第 2 版：使用二维数组，设置「哨兵」行



Java 代码：



```java
import java.util.Scanner;

public class Main {

    // 0-1 背包问题
    // 判题地址：https://www.acwing.com/problem/content/description/2/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        // 多开一行，避免对第 1 行单独赋值
        // 后面要注意下标，有下标 weight[i] 和 value[i] 的地方都要减 1
        int[][] dp = new int[N + 1][V + 1];

        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= V; j++) {
                dp[i][j] = dp[i - 1][j];
                if (weight[i - 1] <= j) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        // 输出
        System.out.println(dp[N][V]);
    }
}
```



### 第 3 版：状态压缩，从后向前写，因为压缩了行，相当于设置了「哨兵」行



Java 代码：



```java
import java.util.Scanner;

public class Main {

    // 0-1 背包问题
    // 判题地址：https://www.acwing.com/problem/content/description/2/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        // 状态压缩的写法：
        int[] dp = new int[V + 1];
        for (int i = 1; i <= N; i++) {
            for (int j = V; j >= weight[i - 1]; j--) {
                dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
            }
        }

        // 输出
        System.out.println(dp[V]);
    }
}
```

第 16.6 节 完全背包问题

### 第 1 版：设置二维状态数组，根据最朴素的「状态转移思想」



Java 代码：



```java
import java.util.Scanner;

public class Main {

    // 完全背包问题
    // 判题地址：https://www.acwing.com/problem/content/3/

    // 参考资料：https://www.acwing.com/solution/acwing/content/5345/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        int[][] dp = new int[N][V + 1];
        // 先写第 1 行

        for (int k = 0; k * weight[0] <= V; k++) {
            dp[0][k * weight[0]] = k * value[0];
        }

        // 最朴素的做法
        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= V; j++) {

                // 多一个 for 循环，枚举下标为 i 的物品可以选的个数
                for (int k = 0; k * weight[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]);
                }
            }
        }

        // 输出
        System.out.println(dp[N - 1][V]);
    }
}
```



做等量代换没有用。



```java
dp[i][j] = max (dp[i - 1][j],
                dp[i - 1][j - v[i]] + w[i],
			    dp[i - 1][j - 2 * v[i]] + 2 * w[i],
			    ...,
			    dp[i - 1][j - k * v[i]] + k * w[i])
```



但是直接从语义出发就比较好理解了，因为每次多考虑的那个物品，也可以从选和不选来考虑，只不过，每次多选的额这个物品参考的当前行的数值。



```java
dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]) + w[i])
```



说明：



1、`dp[i - 1][j]` 表示的是「上一行」的数值，对应的情况是：当前下标为 `i` 的东西「不值钱」，又占地方又廉价，一个都不拿；



2、`dp[i][j - v[i]` 表示的是「这一行」的数值，对应的情况是：当前下标为 `i` 的东西「物小且价格昂贵」，又占不地方又值钱，在不超过背包容量的情况下，应该多拿。



### 第 2 版：设置二维状态数组，填表发现状态转移的规律：之和当前行有关，并且设置了「哨兵」行



Java 代码：



```java
import java.util.Scanner;

public class Main {

    // 完全背包问题
    // 判题地址：https://www.acwing.com/problem/content/3/

    // 参考资料：https://www.acwing.com/solution/acwing/content/5345/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        int[][] dp = new int[N + 1][V + 1];
        // 先写第 1 行


        // 优化
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= V; j++) {
                // 至少是上一行抄下来
                dp[i][j] = dp[i - 1][j];
                if (weight[i - 1] <= j){
                    dp[i][j] = Math.max(dp[i][j], dp[i][j - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        // 输出
        System.out.println(dp[N][V]);
    }
}
```



### 第 3 版：设置二维状态数组，填表发现状态转移的规律：之和当前行有关



Java 代码：



```java
import java.util.Scanner;

public class Main6 {

    // 完全背包问题
    // 判题地址：https://www.acwing.com/problem/content/3/

    // 参考资料：https://www.acwing.com/solution/acwing/content/5345/

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读第 1 行
        int N = scanner.nextInt();
        int V = scanner.nextInt();

        // 读后面的体积和价值
        int[] weight = new int[N];
        int[] value = new int[N];

        for (int i = 0; i < N; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        int[] dp = new int[V + 1];
        // 先写第 1 行

        // 状态压缩
        for (int i = 1; i <= N; i++) {

            // 细节，j 从 weight[i - 1] 开始遍历
            for (int j = weight[i - 1]; j <= V; j++) {
                dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
            }
        }
        // 输出
        System.out.println(dp[V]);
    }
}
```



参考资料：



https://www.acwing.com/solution/acwing/content/3986/

https://www.acwing.com/solution/acwing/content/5345/

https://www.acwing.com/solution/acwing/content/5428/

https://www.acwing.com/solution/acwing/content/5929/

https://www.acwing.com/solution/acwing/content/7493/



视频讲解：



https://www.bilibili.com/video/av91941737?p=2



https://www.bilibili.com/video/av70148899?p=2

第 16.7 节 背包问题

### 练习 1：[「力扣」第 416 题：分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

- 题解：[动态规划（0-1 背包问题）](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/)

### 练习 2：[「力扣」第 322 题： 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

- 题解：[动态规划、使用「完全背包」问题思路、图的广度优先遍历](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)

### 练习 3：[「力扣」第 518 题：零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

- 题解：[动态规划（套用完全背包问题模型）](https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/)

### 练习 4：[「力扣」第 377 题：组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/description/)

- 题解：[动态规划](#KBdut)

### 练习 5：[「力扣」第 474 题：一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

- 题解：[动态规划（转换为 0-1 背包问题）](https://leetcode-cn.com/problems/ones-and-zeroes/solution/dong-tai-gui-hua-zhuan-huan-wei-0-1-bei-bao-wen-ti/)

### 练习 6：[「力扣」第 494 题：目标和](https://leetcode-cn.com/problems/target-sum/)

### 练习 7：[「力扣」第 139 题：单词拆分](https://leetcode-cn.com/problems/word-break/)

- 题解：[动态规划](https://leetcode-cn.com/problems/word-break/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419-2/)

**第 16.8 节 股票问题**



股票问题的通用解法是「动态规划」，因为它符合以下特点：



1、多阶段求解模型：每一天就是一个新的阶段；

2、无后效性：在状态定义准确的前提下，后面阶段的决策参考前面阶段的决策。



总结：



- 121、122、123 都有自己的特殊性，可以结合题目的特点答题；
- 第 188 号问题最难，要搞清楚初始化的时候如何赋值；

- 其它问题只要准确定义状态，状态转移方程不难得到，股票系列问题不是很难，要有信心做出来；
- 如果对这一类问题不熟悉的话，不要一开始就去尝试优化空间（即优化空间）的写法，建议先把把主要精力考虑在定义状态和状态转移上。写对以后，再写优化空间的写法就非常容易了。这些问题的空间都是足够多的，优化空间非必需。而优化空间的技巧，写法是相对固定的，不太熟悉的朋友不用要求自己必须一步到位。



最后一道题是使用单调栈的，与整个系列没有太大关系（算买一赠一，一起做了）。

| 题号                                                         | 题解                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock) | [暴力枚举、动态规划、差分思想](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/) |
| [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii) | [暴力搜索、贪心算法、动态规划](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/) |
| [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii) | [动态规划](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/dong-tai-gui-hua-by-liweiwei1419-7/) |
| [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv) | [动态规划](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/dong-tai-gui-hua-by-liweiwei1419-4/) |
| [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown) | [动态规划](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/) |
| [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) | [动态规划](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/dong-tai-gui-hua-by-liweiwei1419-6/) |
| [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span) | 考察单调栈的用法，[CSDN](https://blog.csdn.net/lw_power/article/details/103957702)。 |





### 参考资料

- [一文教你股票买卖问题实用而装逼的解法](https://mp.weixin.qq.com/s/CWGKl0Ctfc6wStcvBJsD3Q)



第 16.9 节 动态规划题型分类汇总

题目来源：力扣（LeetCode）

作者：FennelDumplings

链接：https://leetcode-cn.com/circle/article/NfHhXD/



学习建议：在一些很难的问题上，不需要话很多时间。

## 

## 区间 DP



「力扣」第 5 题：最长回文子串

「力扣」第 516 题：最长回文子序列

「力扣」第 730 题：统计不同回文子字符串

「力扣」第 1039 题：多边形三角剖分的最低得分

「力扣」第 664 题：奇怪的打印机

「力扣」第 312 题：戳气球



## 字符串匹配问题

72编辑距离

44 通配符匹配

10 正则表达式匹配





## 树形 DP



337 打家劫舍 III



124 二叉树中的最大路径和



1245  树的直径 (邻接表上的树形DP)

543  二叉树的直径

333  最大 BST 子树





状态压缩 DP



「力扣」第 464 题：我能赢吗

「力扣」第 526 题：优美的排列

「力扣」第 935 题：骑士拨号器

「力扣」第 1349 题：参加考试的最大学生数





数位 DP

233  数字 1 的个数

902  最大为 N 的数字组合

1015  可被 K 整除的最小整数





### 计数型 DP

计数型DP都可以以组合数学的方法写出组合数，然后dp求组合数

62  不同路径

63  不同路径 II

96  不同的二叉搜索树 (卡特兰数)

1259  不相交的握手 (卢卡斯定理求大组合数模质数)



### 递推型 DP

所有线性递推关系都可以用矩阵快速幂做，可以O(logN)，最典型是斐波那契数列

70  爬楼梯

509  斐波那契数

935  骑士拨号器

957  N 天后的牢房

1137  第 N 个泰波那契数





### 概率型 DP

求概率，求数学期望

808  分汤

837  新21点



### 博弈型 DP

策梅洛定理，SG 定理，minimax。

#### 1、翻转游戏

[「力扣」第 293 题：翻转游戏](https://leetcode-cn.com/problems/flip-game/)

[「力扣」第 294 题：翻转游戏 II](https://leetcode-cn.com/problems/flip-game-ii/)

#### 2、Nim游戏

[「力扣」第 292 题：Nim 游戏](https://leetcode-cn.com/problems/nim-game/)

#### 3、石子游戏

[「力扣」第 877 题：石子游戏](https://leetcode-cn.com/problems/stone-game/)

[「力扣」第 1140 题：石子游戏 II](https://leetcode-cn.com/problems/stone-game-ii/)



4、井字游戏

[「力扣」第 348 题：判定井字棋胜负](https://leetcode-cn.com/problems/design-tic-tac-toe/)

[「力扣」第 794 题：有效的井字游戏](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/)

[「力扣」第 1275 题：找出井字棋的获胜者](https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/)

### 记忆化搜索

本质是 dfs + 记忆化，用在状态的转移方向不确定的情况。

[「力扣」第 329 题：矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)困难

[「力扣」第 576 题：出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)