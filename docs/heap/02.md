---
title: 第 2 节 优先队列的实现
icon: yongyan
category: 优先队列
tags:
  - 优先队列
  - 堆
---

## 优先队列的几种实现方式

如果不考虑时间复杂度，「优先队列」可以有以下两种实现方式：「无序数组」和「有序数组」。

### 实现 1 ：无序数组

放入的时候，直接放在数组的末尾，时间复杂度：$O(1)$。每次拿出元素之前，我们都排个序，或者像「选择排序」那样，把最大的那个拿出去就好了，时间复杂度是：$O(n)$。

### 实现 2 ：有序数组

每次放入元素的时候，我们都排个序，像插入排序内层循环那样，保持数组的有序性，时间复杂度 $O(n)$，把最大的那个拿出去 $O(1)$。

伟大的计算机科学家平衡了入队和出队这两个操作的时间复杂度，这种数据结构就是「堆」。

### 三种数据结构对于实现优先队列的时间复杂度的比较

| 实现优先队列的数据结构 | 入队操作    | 出队操作    |
| :--------------------- | :---------- | :---------- |
| 普通数组               | $O(1)$      | $O(n)$      |
| 顺序数组               | $O(n)$      | $O(1)$      |
| 堆                     | $O(\log n)$ | $O(\log n)$ |

说明：$\log n$ 表示以 $2$ 为底的 $n$ 的对数。

在 $N$ 个元素中选出前 $M$ 个元素。使用普通数组或者顺序数组，最差的情况是 $O(N^2)$，使用堆可以将时间复杂度降到：$O(N\log M)$。事实上，时间复杂度是 $O(N^2)$ 与 $O(N\log M)$ 的差异巨大的。理解这个事实是我们掌握堆以及相关算法的基础，正是因为使用堆这种数据结构，提高了我们算法的执行效率，我们才有必要来研究堆，使用堆。

我们发现，不管是「入队」还是「出队」，总有一个操作得把「优先队列」中的元素都看一遍。而「堆」就是这样一个数据结构，能把 $O(n)$ 降到 $O(\log n)$。

综上所述，**「堆」是实现「优先队列」的高效的数据结构**。根据出队的元素是 **当前** 整个队中最大的那个元素或者是最小的那个元素，「堆」有「最小堆」和「最大堆」之分。


## 最大堆与最小堆

「优先队列」是一种常见的数据结构，有两种「优先队列」。

+ 一种「优先队列」每次可以从中拿到我们定义下优先级「最高」的元素，即「最大堆」「大顶堆」「大根堆」；
+ 另一种「优先队列」每次可以从中拿到我们定义下优先级「最低」的元素，即「最小堆」「小顶堆」「小根堆」。

::: danger 提示

+ 如果没有特别说明，我们下文所指的「优先队列」都是指每次可以拿到优先级「最高」元素的优先队列，即「大顶堆」「大根堆」；
+ 「最小堆」「小顶堆」「小根堆」的实现我们不讲，原理与「最大堆」是一样的。
  :::

可以看到堆的入队和出队的时间复杂度都是 $O(\log n)$ ，因此我们可以猜测它的形状看起来像是一棵树一样。

## 二叉堆 Binary Heap 的特点

形如下面形状的一个结构就是「最大堆」。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxen9wmnn0j30tg0h8wfh.jpg" alt="image-20211215172649308" style="zoom:50%;" />

- 首先，「最大堆」是一棵「完全二叉树」；

::: info 完全二叉树

从形状上看，除了最后一层之外，其它层结点的数量达到最大值，并且最后一层的结点全部集中在左侧。

:::

「完全二叉树」的特点是：可以使用一个数组保存「完全二叉树」，而不必引入离散的树形结构。这样既可以利用数组元素可以快速访问的特点，又让结点和结点之间形成了「父」与「子」的结构关系。

- 其次，任意一个结点，如果它有孩子结点的话，孩子结点的值一定不会大于父亲结点的值。

::: info 堆有序
如果一个数组中的元素，有如上特点，我们称之为 **堆有序**。
:::

堆有序不是我们通常理解意义上的「升序」或者「降序」。如果把数组排成「完全二叉树」的样子，且满足第 2 条，这个数组就是「堆有序」。这里要注意的是，通常数组的 0 号下标不使用，从 1 号下标开始使用。

这只是一种习惯，因为这么做父子结点的下标关系更「好看」一些，仅此而已。到从 0 号下标开始使用的堆也是可以的。

## 使用数组实现二叉堆

由于最大堆是一颗完全二叉树，我们可以使用「树」这个数据结构来实现。但是，最大堆的一个经典的实现是：使用数组存储二叉堆。

使用数组实现二叉堆的是：自上到下、自左到右对下标进行标记，$0$ 号下标不使用，从 $1$ 号下标开始使用。

## 从下标为 1 开始的数组实现的二叉堆的性质

我们自己画一个二叉堆（如下图），把下标标注在二叉堆上，自上到下、自左到右对下标从 1 号下标开始标记，即显示成结点的旁边黑色的数字，我们不难发现这些数字的排列形成的规律。

正是因为堆是一棵完全二叉树，有如下的规律，我们才可以很方便地下标数组中的位置，这就是我们为什么使用数组而不是使用树来实现堆。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxenaxjmazj30t80gat9p.jpg" alt="image-20211215172748903" style="zoom:50%;" />

上面这张图用数组表示出来，就是一个最大堆。它在我们的程序中是这样表示的：

| 下标号 | 0      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ------ | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 元素值 | `null` | $62$ | $41$ | $22$ | $28$ | $30$ | $16$ | $17$ | $13$ | $19$ | $15$ |

马上我们就可以看到，**完全二叉树这个性质为我们定位这棵树上的结点位置提供了方便**。

看到这里，或许我们在脑子里有个疑问，那么既然堆是一棵树，我们是不是要把堆实现成一个一个结点和指针组成的树呢？其实是可以的，但是我们还注意到 **堆是一棵完全二叉树**，因此把堆用数组存起来会更加方便，因为在一般意义上，操作数组的下标，比操作结点和指针要方便一些，这一点我们马上就会看到。

之所以 $0$ 号下标不使用，是因为从 $1$ 开始下标，对于二叉堆来说，有比较简单的性质。不过根据应用的场景，y有些时候也会使用从 $0$  号下标开始的堆（例如「堆排序」就是这样）。

+ 规律 1：一个结点的左结点的下标是这个结点的编号的 2 倍；
+ 规律 2：一个结点的右结点的下标是这个结点的编号的 2 倍 + 1。

因此，

+ 要想找到父结点：${\rm parent(i)}=\cfrac{i}{2}$，注意这里不能整除的时候需要向下取整；
+ 要想找到两个子结点：${\rm left\ child = 2 \times i}$，${\rm right\ child} = 2 \times i+1$。

::: danger 温馨提示
这个两条性质不用记，我们只要拿一张纸，画一个草图，就能够推出父结点和孩子结点下标之间的关系。
:::



## 体会使用数组来表示一个完全二叉树的好处

在这里啰嗦一句，如果我们使用树结构来保存上面那张图的数据，我们要创建 $10$ 个结点，并且还要指明它们之间的引用关系，那样做显然就太复杂了。下面给出了使用数组实现「最大堆」的一个基本结构。

<CodeGroup>
<CodeGroupItem title="Java">
```java
// 我们这个版本的实现中，0 号下标是不存数据的，这一点一定要注意
public class MaxHeap {

    private int[] data;
    // 当前堆中存储的元素的个数
    private int count;
    
    // 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）
    private int capacity;

    // 初始化最大堆
    public MaxHeap(int capacity) {
        // 初始化底层数组元素（ 0 号下标位置不存数据，这是为了使得通过父结点获得左右孩子有更好的表达式）
        data = new int[capacity + 1];
        count = 0;
    }

    // 返回堆中的元素个数
    public int size() {
        return count;
    }
    
    // 返回一个布尔值，返回堆中是否为空
    public boolean isEmpty() {
        return count == 0;
    }
}
```
</CodeGroupItem>

<CodeGroupItem title="Python">
```python
class MaxHeap:
    def __init__(self, capacity):
        # 我们这个版本的实现中，0 号索引是不存数据的，这一点一定要注意
        # 因为数组从索引 1 开始存放数值
        # 所以开辟 capacity + 1 这么多大小的空间
        self.data = [None for _ in range(capacity + 1)]
        # 当前堆中存储的元素的个数
        self.count = 0
        # 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）
        self.capacity = capacity

    def size(self):
        """
        返回最大堆中的元素的个数
        :return:
        """
        return self.count

    def is_empty(self):
        """
        返回最大堆中的元素是否为空
        :return:
        """
        return self.count == 0
```
</CodeGroupItem>
</CodeGroup>

接下来两节的内容，我们介绍在「优先队列」的「出队」和「入队」操作中，如何保持「最大堆」数组的 **堆有序** 的性质。











