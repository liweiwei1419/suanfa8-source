---
title: 第 1 节 优先队列简介
icon: yongyan
category: 优先队列
tags:
  - 优先队列
  - 堆
---

这一部分我们介绍优先队列（Priority Queue）。

## 「优先队列」与「堆」的关系

+ 优先队列（Priority Queue）是一种「抽象的」数据结构；
+ 堆（Heap）是「具体的」实现，这个系列我们只讲「二叉堆」，其它优先队列的实现不涉及。

## 优先队列用于解决什么样的问题

「优先队列」是从下面的这种场景中抽象出来的数据结构。

班级里要选一名同学代表全班参加程序编程竞赛，此时我们只会关心第 1 名是谁，第 1 名本人不想参赛了，或者说第 1 名因为其它因素不符合参考资格，我们才考虑第 2 名，但也是从剩下的那些同学中挑出第 1 名。

即当前我们 **只关心当前「最优」的那个元素**，第 2 名及其以后的同学都不考虑了。

「优先队列」相对于「普通队列」而言。「普通队列」的性质是「先进先出，后进后出」。「优先队列」由元素的**优先级**决定出队的顺序。

## 普通队列与优先队列

### 普通队列

我们知道「队列」是一种先进先出（FIFO）的数据结构，出队顺序谁先来谁先出去，有点先到先得的意思，日常生活中，随处可见的排队现象，抽象出来，就是「队列」这种数据结构。

### 优先队列

同时，在我们的生活中，有些情况下，并不是按照谁先来，谁先处理的原则来处理事情，例如，我们自己的时间管理，我们会先处理最重要或者是最紧急的事情。又或者是我们非常看不惯的一种现象是，有些服务会针对 VIP 用户优先处理。「优先队列」的思想就类似与我们处理这一类问题的思路，我们按照问题或者任务的重要程度（有的时候称之为优先级），处理觉得更重要，优先级更高的事情，而不是来一个问题就马上处理解决这个问题。

| 普通队列                                             | 优先队列                                                     |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| 先进先出，后进后出。入队的时间顺序决定了出队的顺序。 | 出队顺序与入队顺序无关，只与队列中元素的**优先级**有关，优先级最高的元素最先出队。 |

## 更多「优先队列」在生活中的例子

「优先队列」更多地应用于动态的情况，即数据不是一开始就定好的，而是随时都有可能来新的数据，此时新数据与旧数据在一起选出「优先级」最高的那个元素。比如以下场景，重点理解「动态执行」这个概念：

1. 医院看病：重症患者往往优先治疗，即使他是后来者；
2. 操作系统：选择优先级最高的任务执行；
3. 上网：服务端依次回应客户端的请求：通常也是使用优先队列，优先级高的客户端优先响应；

下面是一个静态的例子：例：从 $1000000$ 个数中选出最大的 $100$ 个数。

这个问题我们抽象成数学表达就是：在 $N$ 个元素中选出前 $M$ 个元素。

1. 如果我们使用之前学习的排序算法，时间复杂度为：$O(N \log N)$，即先排序，再取出前 $M$ 个元素。此时，这个问题的时间复杂度完全由使用的排序算法决定；
2. 如果我们使用优先队列，那么解决该问题的时间复杂度为：$O(N \log M)$。与使用排序算法不同之处在于，我们只要维护有 $M$ 个元素的数据结构就可以了。


## 优先队列的主要操作


「优先队列」的主要操作有：

+ 入队；
+ 出队：优先队列的一个重要特点是：**出队的时候总是取出优先级最高的那个元素**。







